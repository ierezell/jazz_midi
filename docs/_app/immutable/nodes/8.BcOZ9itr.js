import"../chunks/NZTpNUN0.js";import{p as Z,O as M,P as S,Q as $,k as e,c as ee,R as o,f as D,b as z,S as W,d as h,r as _,a as te,W as B,s as b,t as le}from"../chunks/DFYG1ZU2.js";import{d as oe}from"../chunks/BgsxT_DW.js";import{i as re}from"../chunks/iFgn1dkZ.js";import{r as G,i as ae,s as ne}from"../chunks/DD47jCIl.js";import{b as L}from"../chunks/DPC1RNvP.js";import{S as se,N as ce,d as O,M as q}from"../chunks/Cxn_sF4j.js";import{B as ie}from"../chunks/CcldRWvO.js";function de(g,l,m){const a=ce[g+(m?"3":"1")];return se[l].map(v=>a+v)}function ue(g,l,m,c){const a=g.target;o(l,a.checked,!0),o(m,new Set,!0),o(c,[],!0)}function ge(g,l,m,c){const a=g.target;o(l,a.checked,!0),o(m,new Set,!0),o(c,[],!0)}function me(g,l,m,c){const a=g.target;o(l,a.value,!0),o(m,new Set,!0),o(c,[],!0)}var ve=D('<div class="control-group svelte-1l89l8c"><label class="svelte-1l89l8c"><input type="checkbox" class="svelte-1l89l8c"/> In order</label></div> <div class="control-group svelte-1l89l8c"><label class="svelte-1l89l8c"><input type="checkbox" class="svelte-1l89l8c"/> Right hand</label></div> <div class="control-group svelte-1l89l8c"><label for="scaleMode" class="svelte-1l89l8c">Scale mode:</label> <select id="scaleMode" class="svelte-1l89l8c"><option class="svelte-1l89l8c">Major</option><option class="svelte-1l89l8c">Minor</option></select></div>',1),fe=D('<div class="scale-controls svelte-1l89l8c"><!></div>');function we(g,l){Z(l,!0);const m="Play the scale shown, ascending and/or descending, using your MIDI keyboard. Try to follow the correct order.";let c=M(S(l.sequentialMode??(l.randomMode?Math.random()>.5:!0))),a=M(S(l.rightHandMode??(l.randomMode?Math.random()>.5:!0))),v=M(S(l.scaleMode??(l.randomMode?O[Math.floor(Math.random()*O.length)]:"Maj"))),n=M(S(new Set)),d=M(S([]));function F(){o(n,new Set,!0),o(d,[],!0)}function P(r){const t=de(r,e(v),e(a)),s=e(a)?"3":"1";return console.debug(`Scale for ${r}${s}:`,t.map(i=>q[i])),t}function K(r){const s=P(r).map(u=>q[u]),i=e(a)?s.map(u=>[u]):[],p=e(a)?[]:s.map(u=>[u]);return{selectedNote:r,leftHand:p,rightHand:i}}function Q(r,t,s,i){return e(c)?V(t,s):J(t,s)}function V(r,t,s){const i=e(d).length,p=t[i];if(r.noteNumber===p)o(d,[...e(d),r.noteNumber],!0),o(n,new Set([...e(n),r.noteNumber]),!0);else{const u=q[p]?.slice(0,-1)??String(p);return o(d,[],!0),o(n,new Set,!0),{isCorrect:!1,message:`Wrong note! Expected ${u} (note ${i+1})`,collected:!1,resetCollected:!0}}return e(d).length===t.length?{isCorrect:!0,message:"Perfect scale! ðŸŽµâœ¨",collected:!0,resetCollected:!1}:{isCorrect:!0,message:`Good! Note ${i+1}/${t.length}`,collected:!0,resetCollected:!1}}function J(r,t,s){return t.includes(r.noteNumber)?(o(n,new Set([...e(n),r.noteNumber]),!0),e(n).size===t.length?{isCorrect:!0,message:"Perfect scale! ðŸŽµ",collected:e(n).has(r.noteNumber),resetCollected:!1}:{isCorrect:!0,message:`Good! ${e(n).size}/${t.length} notes`,collected:e(n).has(r.noteNumber),resetCollected:!1}):(o(n,new Set,!0),{isCorrect:!1,message:"Wrong note!",resetCollected:!0,collected:!1})}function U(r,t){if(e(c))return e(d).length===t.length&&e(d).every((s,i)=>s===t[i]);{const s=[...new Set(t)];return e(n).size===s.length}}{const r=(i,p=$)=>{var u=fe(),X=h(u);{var Y=N=>{var T=ve(),C=te(T),I=h(C),w=h(I);G(w),w.__change=[ue,c,n,d],B(),_(I),_(C);var y=b(C,2),R=h(y),E=h(R);G(E),E.__change=[ge,a,n,d],B(),_(R),_(y);var A=b(y,2),f=b(h(A),2);f.__change=[me,v,n,d];var k=h(f);k.value=k.__value="Maj";var H=b(k);H.value=H.__value="Min",_(f);var j;ae(f),_(A),le(()=>{j!==(j=e(v))&&(f.value=(f.__value=e(v))??"",ne(f,e(v)))}),L(w,()=>e(c),x=>o(c,x)),L(E,()=>e(a),x=>o(a,x)),z(N,T)};re(X,N=>{l.randomMode||N(Y)})}_(u),z(i,u)};let t=W(()=>l.onComplete??(()=>{})),s=W(()=>l.rootKey||"C");ie(g,{get randomMode(){return l.randomMode},generateExpectedNotes:P,generateScoreProps:K,validateNoteEvent:Q,isCompleted:U,onReset:F,get onComplete(){return e(t)},get initialNote(){return e(s)},description:m,children:r,$$slots:{default:!0}})}ee()}oe(["change"]);export{we as component};
